{"version":3,"sources":["webpack:///vendor/brace/mode/clojure.chunk.js","webpack:////Users/dmp/Code/panneau/js/fields/code/node_modules/brace/mode/clojure.js"],"names":["webpackJsonppanneau","228","module","exports","ace","define","acequire","oop","TextHighlightRules","ClojureHighlightRules","keywordMapper","this","createKeywordMapper","keyword","constant.language","support.function","$rules","start","token","regex","next","string","inherits","Range","MatchingParensOutdent","checkOutdent","line","input","test","autoOutdent","doc","row","getLine","match","column","length","openBracePos","findMatchingBracket","indent","$getIndent","replace","call","prototype","TextMode","Mode","HighlightRules","$outdent","$behaviour","$defaultBehaviour","lineCommentStart","minorIndentFunctions","$toIndent","str","split","map","ch","exec","join","$calculateIndent","tab","isParen","baseIndent","delta","i","substring","iBefore","fn","indexOf","undefined","getNextLineIndent","state","$id"],"mappings":"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","file":"vendor/brace/mode/clojure.chunk.js","sourcesContent":["webpackJsonppanneau([208],{\n\n/***/ 228:\n/***/ (function(module, exports) {\n\nace.define(\"ace/mode/clojure_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"],function(acequire,exports,module){\"use strict\";var oop=acequire(\"../lib/oop\");var TextHighlightRules=acequire(\"./text_highlight_rules\").TextHighlightRules;var ClojureHighlightRules=function ClojureHighlightRules(){var builtinFunctions='* *1 *2 *3 *agent* *allow-unresolved-vars* *assert* *clojure-version* '+'*command-line-args* *compile-files* *compile-path* *e *err* *file* '+'*flush-on-newline* *in* *macro-meta* *math-context* *ns* *out* '+'*print-dup* *print-length* *print-level* *print-meta* *print-readably* '+'*read-eval* *source-path* *use-context-classloader* '+'*warn-on-reflection* + - -> ->> .. / < <= = '+'== > &gt; >= &gt;= accessor aclone '+'add-classpath add-watch agent agent-errors aget alength alias all-ns '+'alter alter-meta! alter-var-root amap ancestors and apply areduce '+'array-map aset aset-boolean aset-byte aset-char aset-double aset-float '+'aset-int aset-long aset-short assert assoc assoc! assoc-in associative? '+'atom await await-for await1 bases bean bigdec bigint binding bit-and '+'bit-and-not bit-clear bit-flip bit-not bit-or bit-set bit-shift-left '+'bit-shift-right bit-test bit-xor boolean boolean-array booleans '+'bound-fn bound-fn* butlast byte byte-array bytes cast char char-array '+'char-escape-string char-name-string char? chars chunk chunk-append '+'chunk-buffer chunk-cons chunk-first chunk-next chunk-rest chunked-seq? '+'class class? clear-agent-errors clojure-version coll? comment commute '+'comp comparator compare compare-and-set! compile complement concat cond '+'condp conj conj! cons constantly construct-proxy contains? count '+'counted? create-ns create-struct cycle dec decimal? declare definline '+'defmacro defmethod defmulti defn defn- defonce defstruct delay delay? '+'deliver deref derive descendants destructure disj disj! dissoc dissoc! '+'distinct distinct? doall doc dorun doseq dosync dotimes doto double '+'double-array doubles drop drop-last drop-while empty empty? ensure '+'enumeration-seq eval even? every? false? ffirst file-seq filter find '+'find-doc find-ns find-var first float float-array float? floats flush '+'fn fn? fnext for force format future future-call future-cancel '+'future-cancelled? future-done? future? gen-class gen-interface gensym '+'get get-in get-method get-proxy-class get-thread-bindings get-validator '+'hash hash-map hash-set identical? identity if-let if-not ifn? import '+'in-ns inc init-proxy instance? int int-array integer? interleave intern '+'interpose into into-array ints io! isa? iterate iterator-seq juxt key '+'keys keyword keyword? last lazy-cat lazy-seq let letfn line-seq list '+'list* list? load load-file load-reader load-string loaded-libs locking '+'long long-array longs loop macroexpand macroexpand-1 make-array '+'make-hierarchy map map? mapcat max max-key memfn memoize merge '+'merge-with meta method-sig methods min min-key mod name namespace neg? '+'newline next nfirst nil? nnext not not-any? not-empty not-every? not= '+'ns ns-aliases ns-imports ns-interns ns-map ns-name ns-publics '+'ns-refers ns-resolve ns-unalias ns-unmap nth nthnext num number? odd? '+'or parents partial partition pcalls peek persistent! pmap pop pop! '+'pop-thread-bindings pos? pr pr-str prefer-method prefers '+'primitives-classnames print print-ctor print-doc print-dup print-method '+'print-namespace-doc print-simple print-special-doc print-str printf '+'println println-str prn prn-str promise proxy proxy-call-with-super '+'proxy-mappings proxy-name proxy-super push-thread-bindings pvalues quot '+'rand rand-int range ratio? rational? rationalize re-find re-groups '+'re-matcher re-matches re-pattern re-seq read read-line read-string '+'reduce ref ref-history-count ref-max-history ref-min-history ref-set '+'refer refer-clojure release-pending-sends rem remove remove-method '+'remove-ns remove-watch repeat repeatedly replace replicate acequire '+'reset! reset-meta! resolve rest resultset-seq reverse reversible? rseq '+'rsubseq second select-keys send send-off seq seq? seque sequence '+'sequential? set set-validator! set? short short-array shorts '+'shutdown-agents slurp some sort sort-by sorted-map sorted-map-by '+'sorted-set sorted-set-by sorted? special-form-anchor special-symbol? '+'split-at split-with str stream? string? struct struct-map subs subseq '+'subvec supers swap! symbol symbol? sync syntax-symbol-anchor take '+'take-last take-nth take-while test the-ns time to-array to-array-2d '+'trampoline transient tree-seq true? type unchecked-add unchecked-dec '+'unchecked-divide unchecked-inc unchecked-multiply unchecked-negate '+'unchecked-remainder unchecked-subtract underive unquote '+'unquote-splicing update-in update-proxy use val vals var-get var-set '+'var? vary-meta vec vector vector? when when-first when-let when-not '+'while with-bindings with-bindings* with-in-str with-loading-context '+'with-local-vars with-meta with-open with-out-str with-precision xml-seq '+'zero? zipmap';var keywords='throw try var '+'def do fn if let loop monitor-enter monitor-exit new quote recur set!';var buildinConstants=\"true false nil\";var keywordMapper=this.createKeywordMapper({\"keyword\":keywords,\"constant.language\":buildinConstants,\"support.function\":builtinFunctions},\"identifier\",false,\" \");this.$rules={\"start\":[{token:\"comment\",regex:\";.*$\"},{token:\"keyword\",//parens\nregex:\"[\\\\(|\\\\)]\"},{token:\"keyword\",//lists\nregex:\"[\\\\'\\\\(]\"},{token:\"keyword\",//vectors\nregex:\"[\\\\[|\\\\]]\"},{token:\"keyword\",//sets and maps\nregex:\"[\\\\{|\\\\}|\\\\#\\\\{|\\\\#\\\\}]\"},{token:\"keyword\",// ampersands\nregex:'[\\\\&]'},{token:\"keyword\",// metadata\nregex:'[\\\\#\\\\^\\\\{]'},{token:\"keyword\",// anonymous fn syntactic sugar\nregex:'[\\\\%]'},{token:\"keyword\",// deref reader macro\nregex:'[@]'},{token:\"constant.numeric\",// hex\nregex:\"0[xX][0-9a-fA-F]+\\\\b\"},{token:\"constant.numeric\",// float\nregex:\"[+-]?\\\\d+(?:(?:\\\\.\\\\d*)?(?:[eE][+-]?\\\\d+)?)?\\\\b\"},{token:\"constant.language\",regex:'[!|\\\\$|%|&|\\\\*|\\\\-\\\\-|\\\\-|\\\\+\\\\+|\\\\+||=|!=|<=|>=|<>|<|>|!|&&]'},{token:keywordMapper,regex:\"[a-zA-Z_$][a-zA-Z0-9_$\\\\-]*\\\\b\"},{token:\"string\",// single line\nregex:'\"',next:\"string\"},{token:\"constant\",// symbol\nregex:/:[^()\\[\\]{}'\"\\^%`,;\\s]+/},{token:\"string.regexp\",//Regular Expressions\nregex:'/#\"(?:\\\\.|(?:\\\\\")|[^\"\"\\n])*\"/g'}],\"string\":[{token:\"constant.language.escape\",regex:\"\\\\\\\\.|\\\\\\\\$\"},{token:\"string\",regex:'[^\"\\\\\\\\]+'},{token:\"string\",regex:'\"',next:\"start\"}]};};oop.inherits(ClojureHighlightRules,TextHighlightRules);exports.ClojureHighlightRules=ClojureHighlightRules;});ace.define(\"ace/mode/matching_parens_outdent\",[\"require\",\"exports\",\"module\",\"ace/range\"],function(acequire,exports,module){\"use strict\";var Range=acequire(\"../range\").Range;var MatchingParensOutdent=function MatchingParensOutdent(){};(function(){this.checkOutdent=function(line,input){if(!/^\\s+$/.test(line))return false;return /^\\s*\\)/.test(input);};this.autoOutdent=function(doc,row){var line=doc.getLine(row);var match=line.match(/^(\\s*\\))/);if(!match)return 0;var column=match[1].length;var openBracePos=doc.findMatchingBracket({row:row,column:column});if(!openBracePos||openBracePos.row==row)return 0;var indent=this.$getIndent(doc.getLine(openBracePos.row));doc.replace(new Range(row,0,row,column-1),indent);};this.$getIndent=function(line){var match=line.match(/^(\\s+)/);if(match){return match[1];}return\"\";};}).call(MatchingParensOutdent.prototype);exports.MatchingParensOutdent=MatchingParensOutdent;});ace.define(\"ace/mode/clojure\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/clojure_highlight_rules\",\"ace/mode/matching_parens_outdent\"],function(acequire,exports,module){\"use strict\";var oop=acequire(\"../lib/oop\");var TextMode=acequire(\"./text\").Mode;var ClojureHighlightRules=acequire(\"./clojure_highlight_rules\").ClojureHighlightRules;var MatchingParensOutdent=acequire(\"./matching_parens_outdent\").MatchingParensOutdent;var Mode=function Mode(){this.HighlightRules=ClojureHighlightRules;this.$outdent=new MatchingParensOutdent();this.$behaviour=this.$defaultBehaviour;};oop.inherits(Mode,TextMode);(function(){this.lineCommentStart=\";\";this.minorIndentFunctions=[\"defn\",\"defn-\",\"defmacro\",\"def\",\"deftest\",\"testing\"];this.$toIndent=function(str){return str.split('').map(function(ch){if(/\\s/.exec(ch)){return ch;}else{return' ';}}).join('');};this.$calculateIndent=function(line,tab){var baseIndent=this.$getIndent(line);var delta=0;var isParen,ch;for(var i=line.length-1;i>=0;i--){ch=line[i];if(ch==='('){delta--;isParen=true;}else if(ch==='('||ch==='['||ch==='{'){delta--;isParen=false;}else if(ch===')'||ch===']'||ch==='}'){delta++;}if(delta<0){break;}}if(delta<0&&isParen){i+=1;var iBefore=i;var fn='';while(true){ch=line[i];if(ch===' '||ch==='\\t'){if(this.minorIndentFunctions.indexOf(fn)!==-1){return this.$toIndent(line.substring(0,iBefore-1)+tab);}else{return this.$toIndent(line.substring(0,i+1));}}else if(ch===undefined){return this.$toIndent(line.substring(0,iBefore-1)+tab);}fn+=line[i];i++;}}else if(delta<0&&!isParen){return this.$toIndent(line.substring(0,i+1));}else if(delta>0){baseIndent=baseIndent.substring(0,baseIndent.length-tab.length);return baseIndent;}else{return baseIndent;}};this.getNextLineIndent=function(state,line,tab){return this.$calculateIndent(line,tab);};this.checkOutdent=function(state,line,input){return this.$outdent.checkOutdent(line,input);};this.autoOutdent=function(state,doc,row){this.$outdent.autoOutdent(doc,row);};this.$id=\"ace/mode/clojure\";}).call(Mode.prototype);exports.Mode=Mode;});\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// vendor/brace/mode/clojure.chunk.js","ace.define(\"ace/mode/clojure_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar oop = acequire(\"../lib/oop\");\nvar TextHighlightRules = acequire(\"./text_highlight_rules\").TextHighlightRules;\n\n\n\nvar ClojureHighlightRules = function() {\n\n    var builtinFunctions = (\n        '* *1 *2 *3 *agent* *allow-unresolved-vars* *assert* *clojure-version* ' +\n        '*command-line-args* *compile-files* *compile-path* *e *err* *file* ' +\n        '*flush-on-newline* *in* *macro-meta* *math-context* *ns* *out* ' +\n        '*print-dup* *print-length* *print-level* *print-meta* *print-readably* ' +\n        '*read-eval* *source-path* *use-context-classloader* ' +\n        '*warn-on-reflection* + - -> ->> .. / < <= = ' +\n        '== > &gt; >= &gt;= accessor aclone ' +\n        'add-classpath add-watch agent agent-errors aget alength alias all-ns ' +\n        'alter alter-meta! alter-var-root amap ancestors and apply areduce ' +\n        'array-map aset aset-boolean aset-byte aset-char aset-double aset-float ' +\n        'aset-int aset-long aset-short assert assoc assoc! assoc-in associative? ' +\n        'atom await await-for await1 bases bean bigdec bigint binding bit-and ' +\n        'bit-and-not bit-clear bit-flip bit-not bit-or bit-set bit-shift-left ' +\n        'bit-shift-right bit-test bit-xor boolean boolean-array booleans ' +\n        'bound-fn bound-fn* butlast byte byte-array bytes cast char char-array ' +\n        'char-escape-string char-name-string char? chars chunk chunk-append ' +\n        'chunk-buffer chunk-cons chunk-first chunk-next chunk-rest chunked-seq? ' +\n        'class class? clear-agent-errors clojure-version coll? comment commute ' +\n        'comp comparator compare compare-and-set! compile complement concat cond ' +\n        'condp conj conj! cons constantly construct-proxy contains? count ' +\n        'counted? create-ns create-struct cycle dec decimal? declare definline ' +\n        'defmacro defmethod defmulti defn defn- defonce defstruct delay delay? ' +\n        'deliver deref derive descendants destructure disj disj! dissoc dissoc! ' +\n        'distinct distinct? doall doc dorun doseq dosync dotimes doto double ' +\n        'double-array doubles drop drop-last drop-while empty empty? ensure ' +\n        'enumeration-seq eval even? every? false? ffirst file-seq filter find ' +\n        'find-doc find-ns find-var first float float-array float? floats flush ' +\n        'fn fn? fnext for force format future future-call future-cancel ' +\n        'future-cancelled? future-done? future? gen-class gen-interface gensym ' +\n        'get get-in get-method get-proxy-class get-thread-bindings get-validator ' +\n        'hash hash-map hash-set identical? identity if-let if-not ifn? import ' +\n        'in-ns inc init-proxy instance? int int-array integer? interleave intern ' +\n        'interpose into into-array ints io! isa? iterate iterator-seq juxt key ' +\n        'keys keyword keyword? last lazy-cat lazy-seq let letfn line-seq list ' +\n        'list* list? load load-file load-reader load-string loaded-libs locking ' +\n        'long long-array longs loop macroexpand macroexpand-1 make-array ' +\n        'make-hierarchy map map? mapcat max max-key memfn memoize merge ' +\n        'merge-with meta method-sig methods min min-key mod name namespace neg? ' +\n        'newline next nfirst nil? nnext not not-any? not-empty not-every? not= ' +\n        'ns ns-aliases ns-imports ns-interns ns-map ns-name ns-publics ' +\n        'ns-refers ns-resolve ns-unalias ns-unmap nth nthnext num number? odd? ' +\n        'or parents partial partition pcalls peek persistent! pmap pop pop! ' +\n        'pop-thread-bindings pos? pr pr-str prefer-method prefers ' +\n        'primitives-classnames print print-ctor print-doc print-dup print-method ' +\n        'print-namespace-doc print-simple print-special-doc print-str printf ' +\n        'println println-str prn prn-str promise proxy proxy-call-with-super ' +\n        'proxy-mappings proxy-name proxy-super push-thread-bindings pvalues quot ' +\n        'rand rand-int range ratio? rational? rationalize re-find re-groups ' +\n        're-matcher re-matches re-pattern re-seq read read-line read-string ' +\n        'reduce ref ref-history-count ref-max-history ref-min-history ref-set ' +\n        'refer refer-clojure release-pending-sends rem remove remove-method ' +\n        'remove-ns remove-watch repeat repeatedly replace replicate acequire ' +\n        'reset! reset-meta! resolve rest resultset-seq reverse reversible? rseq ' +\n        'rsubseq second select-keys send send-off seq seq? seque sequence ' +\n        'sequential? set set-validator! set? short short-array shorts ' +\n        'shutdown-agents slurp some sort sort-by sorted-map sorted-map-by ' +\n        'sorted-set sorted-set-by sorted? special-form-anchor special-symbol? ' +\n        'split-at split-with str stream? string? struct struct-map subs subseq ' +\n        'subvec supers swap! symbol symbol? sync syntax-symbol-anchor take ' +\n        'take-last take-nth take-while test the-ns time to-array to-array-2d ' +\n        'trampoline transient tree-seq true? type unchecked-add unchecked-dec ' +\n        'unchecked-divide unchecked-inc unchecked-multiply unchecked-negate ' +\n        'unchecked-remainder unchecked-subtract underive unquote ' +\n        'unquote-splicing update-in update-proxy use val vals var-get var-set ' +\n        'var? vary-meta vec vector vector? when when-first when-let when-not ' +\n        'while with-bindings with-bindings* with-in-str with-loading-context ' +\n        'with-local-vars with-meta with-open with-out-str with-precision xml-seq ' +\n        'zero? zipmap'\n    );\n\n    var keywords = ('throw try var ' +\n        'def do fn if let loop monitor-enter monitor-exit new quote recur set!'\n    );\n\n    var buildinConstants = (\"true false nil\");\n\n    var keywordMapper = this.createKeywordMapper({\n        \"keyword\": keywords,\n        \"constant.language\": buildinConstants,\n        \"support.function\": builtinFunctions\n    }, \"identifier\", false, \" \");\n\n    this.$rules = {\n        \"start\" : [\n            {\n                token : \"comment\",\n                regex : \";.*$\"\n            }, {\n                token : \"keyword\", //parens\n                regex : \"[\\\\(|\\\\)]\"\n            }, {\n                token : \"keyword\", //lists\n                regex : \"[\\\\'\\\\(]\"\n            }, {\n                token : \"keyword\", //vectors\n                regex : \"[\\\\[|\\\\]]\"\n            }, {\n                token : \"keyword\", //sets and maps\n                regex : \"[\\\\{|\\\\}|\\\\#\\\\{|\\\\#\\\\}]\"\n            }, {\n                    token : \"keyword\", // ampersands\n                    regex : '[\\\\&]'\n            }, {\n                    token : \"keyword\", // metadata\n                    regex : '[\\\\#\\\\^\\\\{]'\n            }, {\n                    token : \"keyword\", // anonymous fn syntactic sugar\n                    regex : '[\\\\%]'\n            }, {\n                    token : \"keyword\", // deref reader macro\n                    regex : '[@]'\n            }, {\n                token : \"constant.numeric\", // hex\n                regex : \"0[xX][0-9a-fA-F]+\\\\b\"\n            }, {\n                token : \"constant.numeric\", // float\n                regex : \"[+-]?\\\\d+(?:(?:\\\\.\\\\d*)?(?:[eE][+-]?\\\\d+)?)?\\\\b\"\n            }, {\n                token : \"constant.language\",\n                regex : '[!|\\\\$|%|&|\\\\*|\\\\-\\\\-|\\\\-|\\\\+\\\\+|\\\\+||=|!=|<=|>=|<>|<|>|!|&&]'\n            }, {\n                token : keywordMapper,\n                regex : \"[a-zA-Z_$][a-zA-Z0-9_$\\\\-]*\\\\b\"\n            }, {\n                token : \"string\", // single line\n                regex : '\"',\n                next: \"string\"\n            }, {\n                token : \"constant\", // symbol\n                regex : /:[^()\\[\\]{}'\"\\^%`,;\\s]+/\n            }, {\n                token : \"string.regexp\", //Regular Expressions\n                regex : '/#\"(?:\\\\.|(?:\\\\\")|[^\"\"\\n])*\"/g'\n            }\n\n        ],\n        \"string\" : [\n            {\n                token : \"constant.language.escape\",\n                regex : \"\\\\\\\\.|\\\\\\\\$\"\n            }, {\n                token : \"string\",\n                regex : '[^\"\\\\\\\\]+'\n            }, {\n                token : \"string\",\n                regex : '\"',\n                next : \"start\"\n            }\n        ]\n    };\n};\n\noop.inherits(ClojureHighlightRules, TextHighlightRules);\n\nexports.ClojureHighlightRules = ClojureHighlightRules;\n});\n\nace.define(\"ace/mode/matching_parens_outdent\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar Range = acequire(\"../range\").Range;\n\nvar MatchingParensOutdent = function() {};\n\n(function() {\n\n    this.checkOutdent = function(line, input) {\n        if (! /^\\s+$/.test(line))\n            return false;\n\n        return /^\\s*\\)/.test(input);\n    };\n\n    this.autoOutdent = function(doc, row) {\n        var line = doc.getLine(row);\n        var match = line.match(/^(\\s*\\))/);\n\n        if (!match) return 0;\n\n        var column = match[1].length;\n        var openBracePos = doc.findMatchingBracket({row: row, column: column});\n\n        if (!openBracePos || openBracePos.row == row) return 0;\n\n        var indent = this.$getIndent(doc.getLine(openBracePos.row));\n        doc.replace(new Range(row, 0, row, column-1), indent);\n    };\n\n    this.$getIndent = function(line) {\n        var match = line.match(/^(\\s+)/);\n        if (match) {\n            return match[1];\n        }\n\n        return \"\";\n    };\n\n}).call(MatchingParensOutdent.prototype);\n\nexports.MatchingParensOutdent = MatchingParensOutdent;\n});\n\nace.define(\"ace/mode/clojure\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/clojure_highlight_rules\",\"ace/mode/matching_parens_outdent\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar oop = acequire(\"../lib/oop\");\nvar TextMode = acequire(\"./text\").Mode;\nvar ClojureHighlightRules = acequire(\"./clojure_highlight_rules\").ClojureHighlightRules;\nvar MatchingParensOutdent = acequire(\"./matching_parens_outdent\").MatchingParensOutdent;\n\nvar Mode = function() {\n    this.HighlightRules = ClojureHighlightRules;\n    this.$outdent = new MatchingParensOutdent();\n    this.$behaviour = this.$defaultBehaviour;\n};\noop.inherits(Mode, TextMode);\n\n(function() {\n\n    this.lineCommentStart = \";\";\n    this.minorIndentFunctions = [\"defn\", \"defn-\", \"defmacro\", \"def\", \"deftest\", \"testing\"];\n\n    this.$toIndent = function(str) {\n        return str.split('').map(function(ch) {\n            if (/\\s/.exec(ch)) {\n                return ch;\n            } else {\n                return ' ';\n            }\n        }).join('');\n    };\n\n    this.$calculateIndent = function(line, tab) {\n        var baseIndent = this.$getIndent(line);\n        var delta = 0;\n        var isParen, ch;\n        for (var i = line.length - 1; i >= 0; i--) {\n            ch = line[i];\n            if (ch === '(') {\n                delta--;\n                isParen = true;\n            } else if (ch === '(' || ch === '[' || ch === '{') {\n                delta--;\n                isParen = false;\n            } else if (ch === ')' || ch === ']' || ch === '}') {\n                delta++;\n            }\n            if (delta < 0) {\n                break;\n            }\n        }\n        if (delta < 0 && isParen) {\n            i += 1;\n            var iBefore = i;\n            var fn = '';\n            while (true) {\n                ch = line[i];\n                if (ch === ' ' || ch === '\\t') {\n                    if(this.minorIndentFunctions.indexOf(fn) !== -1) {\n                        return this.$toIndent(line.substring(0, iBefore - 1) + tab);\n                    } else {\n                        return this.$toIndent(line.substring(0, i + 1));\n                    }\n                } else if (ch === undefined) {\n                    return this.$toIndent(line.substring(0, iBefore - 1) + tab);\n                }\n                fn += line[i];\n                i++;\n            }\n        } else if(delta < 0 && !isParen) {\n            return this.$toIndent(line.substring(0, i+1));\n        } else if(delta > 0) {\n            baseIndent = baseIndent.substring(0, baseIndent.length - tab.length);\n            return baseIndent;\n        } else {\n            return baseIndent;\n        }\n    };\n\n    this.getNextLineIndent = function(state, line, tab) {\n        return this.$calculateIndent(line, tab);\n    };\n\n    this.checkOutdent = function(state, line, input) {\n        return this.$outdent.checkOutdent(line, input);\n    };\n\n    this.autoOutdent = function(state, doc, row) {\n        this.$outdent.autoOutdent(doc, row);\n    };\n\n    this.$id = \"ace/mode/clojure\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n});\n\n\n\n// WEBPACK FOOTER //\n// /Users/dmp/Code/panneau/js/fields/code/node_modules/brace/mode/clojure.js"],"sourceRoot":""}